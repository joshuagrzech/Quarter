"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMockBundledPluginDetails = exports.createTestDevicePlugin = exports.createTestPlugin = exports.createMockPluginDetails = exports.createMockFlipperLib = exports.renderDevicePlugin = exports.startDevicePlugin = exports.renderPlugin = exports.startPlugin = void 0;
const React = __importStar(require("react"));
const react_1 = require("@testing-library/react");
const Plugin_1 = require("../plugin/Plugin");
const SandyPluginDefinition_1 = require("../plugin/SandyPluginDefinition");
const PluginRenderer_1 = require("../plugin/PluginRenderer");
const react_2 = require("@testing-library/react");
const DevicePlugin_1 = require("../plugin/DevicePlugin");
const Logger_1 = require("../utils/Logger");
const atom_1 = require("../state/atom");
function startPlugin(module, options) {
    const definition = new SandyPluginDefinition_1.SandyPluginDefinition(createMockPluginDetails(), module);
    if (definition.isDevicePlugin) {
        throw new Error('Use `startDevicePlugin` or `renderDevicePlugin` to test device plugins');
    }
    const sendStub = jest.fn();
    const flipperUtils = createMockFlipperLib(options);
    const testDevice = createMockDevice(options);
    const appName = 'TestApplication';
    const deviceName = 'TestDevice';
    const fakeFlipperClient = {
        id: `${appName}#${testDevice.os}#${deviceName}#${testDevice.serial}`,
        plugins: [definition.id],
        query: {
            app: appName,
            device: deviceName,
            device_id: testDevice.serial,
            os: testDevice.serial,
        },
        deviceSync: testDevice,
        isBackgroundPlugin(_pluginId) {
            return !!(options === null || options === void 0 ? void 0 : options.isBackgroundPlugin);
        },
        connected: atom_1.createState(true),
        initPlugin() {
            if (options === null || options === void 0 ? void 0 : options.isArchived) {
                return;
            }
            this.connected.set(true);
            pluginInstance.connect();
        },
        deinitPlugin() {
            if (options === null || options === void 0 ? void 0 : options.isArchived) {
                return;
            }
            this.connected.set(false);
            pluginInstance.disconnect();
        },
        call(_api, method, _fromPlugin, params) {
            return sendStub(method, params);
        },
        async supportsMethod(_api, method) {
            var _a;
            return !((_a = options === null || options === void 0 ? void 0 : options.unsupportedMethods) === null || _a === void 0 ? void 0 : _a.includes(method));
        },
    };
    const pluginInstance = new Plugin_1.SandyPluginInstance(flipperUtils, definition, fakeFlipperClient, `${fakeFlipperClient.id}#${definition.id}`, options === null || options === void 0 ? void 0 : options.initialState);
    const res = {
        ...createBasePluginResult(pluginInstance),
        instance: pluginInstance.instanceApi,
        module,
        connect: () => pluginInstance.connect(),
        disconnect: () => pluginInstance.disconnect(),
        onSend: sendStub,
        sendEvent: (event, params) => {
            res.sendEvents([
                {
                    method: event,
                    params,
                },
            ]);
        },
        sendEvents: (messages) => {
            react_2.act(() => {
                pluginInstance.receiveMessages(messages);
            });
        },
    };
    res._backingInstance = pluginInstance;
    if (options === null || options === void 0 ? void 0 : options.isBackgroundPlugin) {
        pluginInstance.connect();
    }
    if (!(options === null || options === void 0 ? void 0 : options.startUnactivated)) {
        pluginInstance.activate();
    }
    return res;
}
exports.startPlugin = startPlugin;
function renderPlugin(module, options) {
    const res = startPlugin(module, options);
    const pluginInstance = res._backingInstance;
    const renderer = react_1.render(React.createElement(PluginRenderer_1.SandyPluginRenderer, { plugin: pluginInstance }));
    return {
        ...res,
        renderer,
        act: react_1.act,
        destroy: () => {
            renderer.unmount();
            pluginInstance.destroy();
        },
    };
}
exports.renderPlugin = renderPlugin;
function startDevicePlugin(module, options) {
    const definition = new SandyPluginDefinition_1.SandyPluginDefinition(createMockPluginDetails({ pluginType: 'device' }), module);
    if (!definition.isDevicePlugin) {
        throw new Error('Use `startPlugin` or `renderPlugin` to test non-device plugins');
    }
    const flipperLib = createMockFlipperLib(options);
    const testDevice = createMockDevice(options);
    testDevice.devicePlugins.push(definition.id);
    const pluginInstance = new DevicePlugin_1.SandyDevicePluginInstance(flipperLib, definition, testDevice, `${testDevice.serial}#${definition.id}`, options === null || options === void 0 ? void 0 : options.initialState);
    const res = {
        ...createBasePluginResult(pluginInstance),
        module,
        instance: pluginInstance.instanceApi,
        sendLogEntry: (entry) => {
            react_2.act(() => {
                testDevice.addLogEntry(entry);
            });
        },
    };
    res._backingInstance = pluginInstance;
    pluginInstance.activate();
    return res;
}
exports.startDevicePlugin = startDevicePlugin;
function renderDevicePlugin(module, options) {
    const res = startDevicePlugin(module, options);
    const pluginInstance = res
        ._backingInstance;
    const renderer = react_1.render(React.createElement(PluginRenderer_1.SandyPluginRenderer, { plugin: pluginInstance }));
    return {
        ...res,
        renderer,
        act: react_1.act,
        destroy: () => {
            renderer.unmount();
            pluginInstance.destroy();
        },
    };
}
exports.renderDevicePlugin = renderDevicePlugin;
function createMockFlipperLib(options) {
    return {
        isFB: false,
        logger: Logger_1.stubLogger,
        enableMenuEntries: jest.fn(),
        createPaste: jest.fn(),
        GK(gk) {
            var _a;
            return ((_a = options === null || options === void 0 ? void 0 : options.GKs) === null || _a === void 0 ? void 0 : _a.includes(gk)) || false;
        },
        selectPlugin: jest.fn(),
        isPluginAvailable: jest.fn().mockImplementation(() => false),
        writeTextToClipboard: jest.fn(),
        showNotification: jest.fn(),
    };
}
exports.createMockFlipperLib = createMockFlipperLib;
function createBasePluginResult(pluginInstance) {
    return {
        flipperLib: pluginInstance.flipperLib,
        activate: () => pluginInstance.activate(),
        deactivate: () => pluginInstance.deactivate(),
        exportStateAsync: () => pluginInstance.exportState(createStubIdler(), () => { }),
        exportState: () => pluginInstance.exportStateSync(),
        triggerDeepLink: async (deepLink) => {
            pluginInstance.triggerDeepLink(deepLink);
            return new Promise((resolve) => {
                setImmediate(resolve);
            });
        },
        destroy: () => pluginInstance.destroy(),
        triggerMenuEntry: (action) => {
            const entry = pluginInstance.menuEntries.find((e) => e.action === action);
            if (!entry) {
                throw new Error('No menu entry found with action: ' + action);
            }
            entry.handler();
        },
    };
}
function createMockPluginDetails(details) {
    return {
        id: 'TestPlugin',
        dir: '',
        name: 'TestPlugin',
        specVersion: 0,
        entry: '',
        isBundled: false,
        isActivatable: true,
        main: '',
        source: '',
        title: 'Testing Plugin',
        version: '',
        ...details,
    };
}
exports.createMockPluginDetails = createMockPluginDetails;
function createTestPlugin(implementation, details) {
    return new SandyPluginDefinition_1.SandyPluginDefinition(createMockPluginDetails({
        pluginType: 'client',
        ...details,
    }), {
        Component() {
            return null;
        },
        ...implementation,
    });
}
exports.createTestPlugin = createTestPlugin;
function createTestDevicePlugin(implementation, details) {
    return new SandyPluginDefinition_1.SandyPluginDefinition(createMockPluginDetails({
        pluginType: 'device',
        ...details,
    }), {
        supportsDevice() {
            return true;
        },
        Component() {
            return null;
        },
        ...implementation,
    });
}
exports.createTestDevicePlugin = createTestDevicePlugin;
function createMockBundledPluginDetails(details) {
    return {
        id: 'TestBundledPlugin',
        name: 'TestBundledPlugin',
        specVersion: 0,
        pluginType: 'client',
        isBundled: true,
        isActivatable: true,
        main: '',
        source: '',
        title: 'Testing Bundled Plugin',
        version: '',
        ...details,
    };
}
exports.createMockBundledPluginDetails = createMockBundledPluginDetails;
function createMockDevice(options) {
    const logListeners = [];
    return {
        os: 'Android',
        deviceType: 'emulator',
        serial: 'serial-000',
        isArchived: !!(options === null || options === void 0 ? void 0 : options.isArchived),
        connected: atom_1.createState(true),
        devicePlugins: [],
        addLogListener(cb) {
            logListeners.push(cb);
            return (logListeners.length - 1);
        },
        removeLogListener(idx) {
            logListeners[idx] = undefined;
        },
        addLogEntry(entry) {
            logListeners.forEach((f) => f === null || f === void 0 ? void 0 : f(entry));
        },
    };
}
function createStubIdler() {
    return {
        shouldIdle() {
            return false;
        },
        idle() {
            return Promise.resolve();
        },
        cancel() { },
        isCancelled() {
            return false;
        },
    };
}
//# sourceMappingURL=test-utils.js.map