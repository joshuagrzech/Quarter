declare type AppendEvent<T> = {
    type: 'append';
    entry: Entry<T>;
};
declare type UpdateEvent<T> = {
    type: 'update';
    entry: Entry<T>;
    oldValue: T;
    oldVisible: boolean;
    index: number;
};
declare type RemoveEvent<T> = {
    type: 'remove';
    entry: Entry<T>;
    index: number;
};
declare type ShiftEvent<T> = {
    type: 'shift';
    entries: Entry<T>[];
    amount: number;
};
declare type DataEvent<T> = AppendEvent<T> | UpdateEvent<T> | RemoveEvent<T> | ShiftEvent<T>;
declare type Entry<T> = {
    value: T;
    id: number;
    visible: boolean;
    approxIndex: number;
};
declare type Primitive = number | string | boolean | null | undefined;
declare type OutputChange = {
    type: 'shift';
    index: number;
    location: 'before' | 'in' | 'after';
    delta: number;
    newCount: number;
} | {
    type: 'update';
    index: number;
} | {
    type: 'reset';
    newCount: number;
};
export declare type DataSourceOptions<T, K extends keyof T> = {
    key?: K;
    limit?: number;
};
export declare function createDataSource<T, KEY extends keyof T = any>(initialSet: readonly T[], options?: DataSourceOptions<T, KEY>): DataSource<T>;
export declare function createDataSource<T>(initialSet?: readonly T[]): DataSource<T>;
export declare class DataSource<T> {
    private nextId;
    private _records;
    private _recordsById;
    keyAttribute: keyof T | undefined;
    private idToIndex;
    private shiftOffset;
    limit: number;
    readonly view: DataSourceView<T>;
    constructor(keyAttribute: keyof T | undefined);
    get size(): number;
    records(): readonly T[];
    get(index: number): T;
    has(key: string): boolean;
    getById(key: string): T | undefined;
    keys(): IterableIterator<string>;
    entries(): IterableIterator<[string, T]>;
    [Symbol.iterator](): IterableIterator<T>;
    getIndexOfKey(key: string): number;
    append(value: T): void;
    upsert(value: T): boolean;
    update(index: number, value: T): void;
    delete(index: number): void;
    deleteByKey(keyValue: string): boolean;
    shift(amount: number): void;
    clear(): void;
    fork(): DataSourceView<T>;
    private assertKeySet;
    private getKey;
    private storeIndexOfKey;
    private emitDataEvent;
    serialize(): readonly T[];
    deserialize(value: any[]): void;
}
declare class DataSourceView<T> {
    readonly datasource: DataSource<T>;
    private sortBy;
    private reverse;
    private filter?;
    windowStart: number;
    windowEnd: number;
    private outputChangeListener?;
    private _output;
    constructor(datasource: DataSource<T>);
    get size(): number;
    get isSorted(): boolean;
    get isFiltered(): boolean;
    get isReversed(): boolean;
    output(start?: number, end?: number): readonly T[];
    setWindow(start: number, end: number): void;
    setListener(listener?: (change: OutputChange) => void): void;
    setSortBy(sortBy: undefined | keyof T | ((a: T) => Primitive)): void;
    setFilter(filter: undefined | ((value: T) => boolean)): void;
    toggleReversed(): void;
    setReversed(reverse: boolean): void;
    reset(): void;
    private normalizeIndex;
    get(viewIndex: number): T;
    [Symbol.iterator](): IterableIterator<T>;
    private notifyItemUpdated;
    private notifyItemShift;
    private notifyReset;
    processEvent(event: DataEvent<T>): void;
    private processRemoveEvent;
    rebuild(): void;
    private sortHelper;
    private getSortedIndex;
    private insertSorted;
}
export {};
//# sourceMappingURL=DataSource.d.ts.map