"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataSource = exports.createDataSource = void 0;
const sortedIndexBy_1 = __importDefault(require("lodash/sortedIndexBy"));
const sortedLastIndexBy_1 = __importDefault(require("lodash/sortedLastIndexBy"));
const property_1 = __importDefault(require("lodash/property"));
const sortBy_1 = __importDefault(require("lodash/sortBy"));
const dropFactor = 0.1;
const defaultLimit = 100 * 1000;
const shiftRebuildTreshold = 0.05;
function createDataSource(initialSet = [], options) {
    const ds = new DataSource(options === null || options === void 0 ? void 0 : options.key);
    if ((options === null || options === void 0 ? void 0 : options.limit) !== undefined) {
        ds.limit = options.limit;
    }
    initialSet.forEach((value) => ds.append(value));
    return ds;
}
exports.createDataSource = createDataSource;
class DataSource {
    constructor(keyAttribute) {
        this.nextId = 0;
        this._records = [];
        this._recordsById = new Map();
        this.idToIndex = new Map();
        this.shiftOffset = 0;
        this.limit = defaultLimit;
        this.keyAttribute = keyAttribute;
        this.view = new DataSourceView(this);
    }
    get size() {
        return this._records.length;
    }
    records() {
        return this._records.map(unwrap);
    }
    get(index) {
        return unwrap(this._records[index]);
    }
    has(key) {
        this.assertKeySet();
        return this._recordsById.has(key);
    }
    getById(key) {
        this.assertKeySet();
        return this._recordsById.get(key);
    }
    keys() {
        this.assertKeySet();
        return this._recordsById.keys();
    }
    entries() {
        this.assertKeySet();
        return this._recordsById.entries();
    }
    [Symbol.iterator]() {
        const self = this;
        let offset = 0;
        return {
            next() {
                offset++;
                if (offset > self.size) {
                    return { done: true, value: undefined };
                }
                else {
                    return {
                        value: self._records[offset - 1].value,
                    };
                }
            },
            [Symbol.iterator]() {
                return this;
            },
        };
    }
    getIndexOfKey(key) {
        this.assertKeySet();
        const stored = this.idToIndex.get(key);
        return stored === undefined ? -1 : stored + this.shiftOffset;
    }
    append(value) {
        if (this._records.length >= this.limit) {
            this.shift(Math.ceil(this.limit * dropFactor));
        }
        if (this.keyAttribute) {
            const key = this.getKey(value);
            if (this._recordsById.has(key)) {
                throw new Error(`Duplicate key: '${key}'`);
            }
            this._recordsById.set(key, value);
            this.storeIndexOfKey(key, this._records.length);
        }
        const entry = {
            value,
            id: ++this.nextId,
            visible: true,
            approxIndex: -1,
        };
        this._records.push(entry);
        this.emitDataEvent({
            type: 'append',
            entry,
        });
    }
    upsert(value) {
        this.assertKeySet();
        const key = this.getKey(value);
        if (this.idToIndex.has(key)) {
            this.update(this.getIndexOfKey(key), value);
            return true;
        }
        else {
            this.append(value);
            return false;
        }
    }
    update(index, value) {
        const entry = this._records[index];
        const oldValue = entry.value;
        if (value === oldValue) {
            return;
        }
        const oldVisible = entry.visible;
        entry.value = value;
        if (this.keyAttribute) {
            const key = this.getKey(value);
            const currentKey = this.getKey(oldValue);
            if (currentKey !== key) {
                const existingIndex = this.getIndexOfKey(key);
                if (existingIndex !== -1 && existingIndex !== index) {
                    throw new Error(`Trying to insert duplicate key '${key}', which already exist in the collection`);
                }
                this._recordsById.delete(currentKey);
                this.idToIndex.delete(currentKey);
            }
            this._recordsById.set(key, value);
            this.storeIndexOfKey(key, index);
        }
        this.emitDataEvent({
            type: 'update',
            entry,
            oldValue,
            oldVisible,
            index,
        });
    }
    delete(index) {
        if (index < 0 || index >= this._records.length) {
            throw new Error('Out of bounds: ' + index);
        }
        const entry = this._records.splice(index, 1)[0];
        if (this.keyAttribute) {
            const key = this.getKey(entry.value);
            this._recordsById.delete(key);
            this.idToIndex.delete(key);
            if (index === 0) {
                this.shiftOffset -= 1;
            }
            else {
                this.idToIndex.forEach((keyIndex, key) => {
                    if (keyIndex + this.shiftOffset > index)
                        this.storeIndexOfKey(key, keyIndex - 1);
                });
            }
        }
        this.emitDataEvent({
            type: 'remove',
            index,
            entry,
        });
    }
    deleteByKey(keyValue) {
        this.assertKeySet();
        const index = this.getIndexOfKey(keyValue);
        if (index === -1) {
            return false;
        }
        this.delete(index);
        return true;
    }
    shift(amount) {
        amount = Math.min(amount, this._records.length);
        if (amount === this._records.length) {
            this.clear();
            return;
        }
        this.shiftOffset -= amount;
        const removed = this._records.splice(0, amount);
        if (this.keyAttribute) {
            removed.forEach((entry) => {
                const key = this.getKey(entry.value);
                this._recordsById.delete(key);
                this.idToIndex.delete(key);
            });
        }
        if (this.view.isSorted &&
            removed.length > 10 &&
            removed.length > shiftRebuildTreshold * this._records.length) {
            this.view.rebuild();
        }
        else {
            this.emitDataEvent({
                type: 'shift',
                entries: removed,
                amount,
            });
        }
    }
    clear() {
        this._records = [];
        this._recordsById = new Map();
        this.shiftOffset = 0;
        this.idToIndex = new Map();
        this.view.rebuild();
    }
    fork() {
        throw new Error('Not implemented. Please contact oncall if this feature is needed');
    }
    assertKeySet() {
        if (!this.keyAttribute) {
            throw new Error('No key has been set. Records cannot be looked up by key');
        }
    }
    getKey(value) {
        this.assertKeySet();
        const key = value[this.keyAttribute];
        if ((typeof key === 'string' || typeof key === 'number') && key !== '') {
            return key;
        }
        throw new Error(`Invalid key value: '${key}'`);
    }
    storeIndexOfKey(key, index) {
        this.idToIndex.set(key, index - this.shiftOffset);
    }
    emitDataEvent(event) {
        this.view.processEvent(event);
    }
    serialize() {
        return this.records();
    }
    deserialize(value) {
        this.clear();
        value.forEach((record) => {
            this.append(record);
        });
    }
}
exports.DataSource = DataSource;
function unwrap(entry) {
    return entry === null || entry === void 0 ? void 0 : entry.value;
}
class DataSourceView {
    constructor(datasource) {
        this.sortBy = undefined;
        this.reverse = false;
        this.filter = undefined;
        this.windowStart = 0;
        this.windowEnd = 0;
        this._output = [];
        this.sortHelper = (a) => this.sortBy ? this.sortBy(a.value) : a.id;
        this.datasource = datasource;
    }
    get size() {
        return this._output.length;
    }
    get isSorted() {
        return !!this.sortBy;
    }
    get isFiltered() {
        return !!this.filter;
    }
    get isReversed() {
        return this.reverse;
    }
    output(start = this.windowStart, end = this.windowEnd) {
        if (this.reverse) {
            return this._output
                .slice(this._output.length - end, this._output.length - start)
                .reverse()
                .map((e) => e.value);
        }
        else {
            return this._output.slice(start, end).map((e) => e.value);
        }
    }
    setWindow(start, end) {
        this.windowStart = start;
        this.windowEnd = end;
    }
    setListener(listener) {
        if (this.outputChangeListener && listener) {
            console.warn('outputChangeListener already set');
        }
        this.outputChangeListener = listener;
    }
    setSortBy(sortBy) {
        if (this.sortBy === sortBy) {
            return;
        }
        if (typeof sortBy === 'string' &&
            (!this.sortBy || this.sortBy.sortByKey !== sortBy)) {
            sortBy = property_1.default(sortBy);
            Object.assign(sortBy, {
                sortByKey: sortBy,
            });
        }
        this.sortBy = sortBy;
        this.rebuild();
    }
    setFilter(filter) {
        if (this.filter !== filter) {
            this.filter = filter;
            this.rebuild();
        }
    }
    toggleReversed() {
        this.setReversed(!this.reverse);
    }
    setReversed(reverse) {
        if (this.reverse !== reverse) {
            this.reverse = reverse;
            this.notifyReset(this._output.length);
        }
    }
    reset() {
        this.sortBy = undefined;
        this.reverse = false;
        this.filter = undefined;
        this.windowStart = 0;
        this.windowEnd = 0;
        this.rebuild();
    }
    normalizeIndex(viewIndex) {
        return this.reverse ? this._output.length - 1 - viewIndex : viewIndex;
    }
    get(viewIndex) {
        var _a;
        return (_a = this._output[this.normalizeIndex(viewIndex)]) === null || _a === void 0 ? void 0 : _a.value;
    }
    [Symbol.iterator]() {
        const self = this;
        let offset = this.windowStart;
        return {
            next() {
                offset++;
                if (offset > self.windowEnd || offset > self.size) {
                    return { done: true, value: undefined };
                }
                else {
                    return {
                        value: self.get(offset - 1),
                    };
                }
            },
            [Symbol.iterator]() {
                return this;
            },
        };
    }
    notifyItemUpdated(viewIndex) {
        viewIndex = this.normalizeIndex(viewIndex);
        if (!this.outputChangeListener ||
            viewIndex < this.windowStart ||
            viewIndex >= this.windowEnd) {
            return;
        }
        this.outputChangeListener({
            type: 'update',
            index: viewIndex,
        });
    }
    notifyItemShift(index, delta) {
        if (!this.outputChangeListener) {
            return;
        }
        let viewIndex = this.normalizeIndex(index);
        if (this.reverse && delta < 0) {
            viewIndex -= delta;
        }
        this.outputChangeListener({
            type: 'shift',
            delta,
            index: viewIndex,
            newCount: this._output.length,
            location: viewIndex < this.windowStart
                ? 'before'
                : viewIndex >= this.windowEnd
                    ? 'after'
                    : 'in',
        });
    }
    notifyReset(count) {
        var _a;
        (_a = this.outputChangeListener) === null || _a === void 0 ? void 0 : _a.call(this, {
            type: 'reset',
            newCount: count,
        });
    }
    processEvent(event) {
        const { _output: output, sortBy, filter } = this;
        switch (event.type) {
            case 'append': {
                const { entry } = event;
                entry.visible = filter ? filter(entry.value) : true;
                if (!entry.visible) {
                    return;
                }
                if (!sortBy) {
                    entry.approxIndex = output.length;
                    output.push(entry);
                    this.notifyItemShift(entry.approxIndex, 1);
                }
                else {
                    this.insertSorted(entry);
                }
                break;
            }
            case 'update': {
                const { entry } = event;
                entry.visible = filter ? filter(entry.value) : true;
                if (!filter && !sortBy) {
                    output[event.index].approxIndex = event.index;
                    this.notifyItemUpdated(event.index);
                }
                else if (!event.oldVisible) {
                    if (!entry.visible) {
                    }
                    else {
                        this.insertSorted(entry);
                    }
                }
                else {
                    const existingIndex = this.getSortedIndex(entry, event.oldValue);
                    if (!entry.visible) {
                        output.splice(existingIndex, 1);
                        this.notifyItemShift(existingIndex, -1);
                    }
                    else {
                        if (!this.sortBy ||
                            this.sortBy(event.oldValue) === this.sortBy(entry.value)) {
                            this.notifyItemUpdated(existingIndex);
                        }
                        else {
                            output.splice(existingIndex, 1);
                            this.notifyItemShift(existingIndex, -1);
                            this.insertSorted(entry);
                        }
                    }
                }
                break;
            }
            case 'remove': {
                this.processRemoveEvent(event.index, event.entry);
                break;
            }
            case 'shift': {
                if (!sortBy) {
                    let amount = 0;
                    if (!filter) {
                        amount = event.amount;
                    }
                    else {
                        for (let i = 0; i < event.entries.length; i++)
                            if (event.entries[i].visible)
                                amount++;
                    }
                    output.splice(0, amount);
                    this.notifyItemShift(0, -amount);
                }
                else {
                    for (let i = event.entries.length - 1; i >= 0; i--) {
                        this.processRemoveEvent(i, event.entries[i]);
                    }
                }
                break;
            }
            default:
                throw new Error('unknown event type');
        }
    }
    processRemoveEvent(index, entry) {
        const { _output: output, sortBy, filter } = this;
        if (!entry.visible) {
            return;
        }
        if (!sortBy && !filter) {
            output.splice(index, 1);
            this.notifyItemShift(index, -1);
        }
        else {
            const existingIndex = this.getSortedIndex(entry, entry.value);
            output.splice(existingIndex, 1);
            this.notifyItemShift(existingIndex, -1);
        }
    }
    rebuild() {
        const { sortBy, filter, sortHelper } = this;
        const records = this.datasource._records;
        let output = filter
            ? records.filter((entry) => {
                entry.visible = filter(entry.value);
                return entry.visible;
            })
            : records.slice();
        if (sortBy) {
            output = sortBy_1.default(output, sortHelper);
        }
        this._output = output;
        this.notifyReset(output.length);
    }
    getSortedIndex(entry, oldValue) {
        const { _output: output } = this;
        if (output[entry.approxIndex] === entry) {
            return entry.approxIndex;
        }
        let index = sortedIndexBy_1.default(output, {
            value: oldValue,
            id: -1,
            visible: true,
            approxIndex: -1,
        }, this.sortHelper);
        index--;
        while (output[index] !== entry) {
            index++;
            if (index >= output.length) {
                throw new Error('illegal state: sortedIndex not found');
            }
        }
        return index;
    }
    insertSorted(entry) {
        const insertionIndex = sortedLastIndexBy_1.default(this._output, entry, this.sortHelper);
        entry.approxIndex = insertionIndex;
        this._output.splice(insertionIndex, 0, entry);
        this.notifyItemShift(insertionIndex, 1);
    }
}
//# sourceMappingURL=DataSource.js.map