"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useTableRedraw = exports.RedrawContext = exports.DataSourceRendererVirtual = void 0;
const react_1 = __importStar(require("react"));
const react_virtual_1 = require("react-virtual");
const observe_rect_1 = __importDefault(require("@reach/observe-rect"));
const LOW_PRIO_UPDATE = 1000;
const HIGH_PRIO_UPDATE = 40;
const SMALL_DATASET = 1000;
var UpdatePrio;
(function (UpdatePrio) {
    UpdatePrio[UpdatePrio["NONE"] = 0] = "NONE";
    UpdatePrio[UpdatePrio["LOW"] = 1] = "LOW";
    UpdatePrio[UpdatePrio["HIGH"] = 2] = "HIGH";
})(UpdatePrio || (UpdatePrio = {}));
exports.DataSourceRendererVirtual = react_1.memo(function DataSourceRendererVirtual({ dataSource, defaultRowHeight, useFixedRowHeight, context, itemRenderer, autoScroll, onKeyDown, virtualizerRef, onRangeChange, onUpdateAutoScroll, emptyRenderer, }) {
    const renderPending = react_1.useRef(UpdatePrio.NONE);
    const lastRender = react_1.useRef(Date.now());
    const [, setForceUpdate] = react_1.useState(0);
    const forceHeightRecalculation = react_1.useRef(0);
    const parentRef = react_1.default.useRef(null);
    const isUnitTest = useInUnitTest();
    const virtualizer = react_virtual_1.useVirtual({
        size: dataSource.view.size,
        parentRef,
        useObserver: isUnitTest ? () => ({ height: 500, width: 1000 }) : undefined,
        estimateSize: react_1.useCallback(() => defaultRowHeight, [forceHeightRecalculation.current, defaultRowHeight]),
        overscan: 0,
    });
    if (virtualizerRef) {
        virtualizerRef.current = virtualizer;
    }
    const redraw = react_1.useCallback(() => {
        forceHeightRecalculation.current++;
        setForceUpdate((x) => x + 1);
    }, []);
    react_1.useEffect(function subscribeToDataSource() {
        const forceUpdate = () => {
            if (unmounted) {
                return;
            }
            timeoutHandle = undefined;
            setForceUpdate((x) => x + 1);
        };
        let unmounted = false;
        let timeoutHandle = undefined;
        function rerender(prio, invalidateHeights = false) {
            if (invalidateHeights && !useFixedRowHeight) {
                forceHeightRecalculation.current++;
            }
            if (isUnitTest) {
                forceUpdate();
                return;
            }
            if (renderPending.current >= prio) {
                return;
            }
            renderPending.current = Math.max(renderPending.current, prio);
            if (prio === UpdatePrio.LOW) {
                if (!timeoutHandle) {
                    timeoutHandle = setTimeout(forceUpdate, LOW_PRIO_UPDATE);
                }
            }
            else {
                if (timeoutHandle) {
                    clearTimeout(timeoutHandle);
                    timeoutHandle = undefined;
                }
                if (lastRender.current < Date.now() - HIGH_PRIO_UPDATE) {
                    forceUpdate();
                }
                else {
                    timeoutHandle = setTimeout(forceUpdate, HIGH_PRIO_UPDATE);
                }
            }
        }
        dataSource.view.setListener((event) => {
            switch (event.type) {
                case 'reset':
                    rerender(UpdatePrio.HIGH, true);
                    break;
                case 'shift':
                    if (dataSource.view.size < SMALL_DATASET) {
                        rerender(UpdatePrio.HIGH, false);
                    }
                    else if (event.location === 'in' ||
                        (event.location === 'after' &&
                            event.delta > 0 &&
                            event.index === dataSource.view.windowEnd)) {
                        rerender(UpdatePrio.HIGH, false);
                    }
                    else {
                        rerender(UpdatePrio.LOW, false);
                    }
                    break;
                case 'update':
                    rerender(UpdatePrio.HIGH, true);
                    break;
            }
        });
        return () => {
            unmounted = true;
            dataSource.view.setListener(undefined);
        };
    }, [dataSource, setForceUpdate, useFixedRowHeight, isUnitTest]);
    react_1.useEffect(() => {
        setForceUpdate((x) => x + 1);
    }, [setForceUpdate]);
    react_1.useLayoutEffect(function updateWindow() {
        var _a, _b, _c, _d;
        const start = (_b = (_a = virtualizer.virtualItems[0]) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : 0;
        const end = start + virtualizer.virtualItems.length;
        if (start !== dataSource.view.windowStart && !autoScroll) {
            onRangeChange === null || onRangeChange === void 0 ? void 0 : onRangeChange(start, end, dataSource.view.size, (_d = (_c = parentRef.current) === null || _c === void 0 ? void 0 : _c.scrollTop) !== null && _d !== void 0 ? _d : 0);
        }
        dataSource.view.setWindow(start, end);
    });
    const onScroll = react_1.useCallback(() => {
        const elem = parentRef.current;
        if (!elem) {
            return;
        }
        const fromEnd = elem.scrollHeight - elem.scrollTop - elem.clientHeight;
        if (autoScroll && fromEnd > 1) {
            onUpdateAutoScroll === null || onUpdateAutoScroll === void 0 ? void 0 : onUpdateAutoScroll(false);
        }
        else if (!autoScroll && fromEnd < 1) {
            onUpdateAutoScroll === null || onUpdateAutoScroll === void 0 ? void 0 : onUpdateAutoScroll(true);
        }
    }, [onUpdateAutoScroll, autoScroll]);
    react_1.useLayoutEffect(function scrollToEnd() {
        if (autoScroll) {
            virtualizer.scrollToIndex(dataSource.view.size - 1, {
                align: 'end',
                behavior: 'smooth',
            });
        }
    });
    react_1.useEffect(function renderCompleted() {
        renderPending.current = UpdatePrio.NONE;
        lastRender.current = Date.now();
    });
    react_1.useEffect(function redrawOnResize() {
        if (!parentRef.current) {
            return;
        }
        let lastWidth = 0;
        const observer = observe_rect_1.default(parentRef.current, (rect) => {
            if (lastWidth !== rect.width) {
                lastWidth = rect.width;
                redraw();
            }
        });
        observer.observe();
        return () => observer.unobserve();
    }, [redraw]);
    return (react_1.default.createElement(exports.RedrawContext.Provider, { value: redraw },
        react_1.default.createElement("div", { ref: parentRef, onScroll: onScroll, style: tableContainerStyle },
            virtualizer.virtualItems.length === 0
                ? emptyRenderer === null || emptyRenderer === void 0 ? void 0 : emptyRenderer(dataSource)
                : null,
            react_1.default.createElement("div", { style: {
                    ...tableWindowStyle,
                    height: virtualizer.totalSize,
                }, onKeyDown: onKeyDown, tabIndex: 0 }, virtualizer.virtualItems.map((virtualRow) => {
                const value = dataSource.view.get(virtualRow.index);
                return (react_1.default.createElement("div", { key: virtualRow.index, style: {
                        position: 'absolute',
                        top: 0,
                        left: 0,
                        width: '100%',
                        height: useFixedRowHeight ? virtualRow.size : undefined,
                        transform: `translateY(${virtualRow.start}px)`,
                    }, ref: useFixedRowHeight ? undefined : virtualRow.measureRef }, itemRenderer(value, virtualRow.index, context)));
            })))));
});
const tableContainerStyle = {
    overflowY: 'auto',
    overflowX: 'hidden',
    display: 'flex',
    flex: `1 1 0`,
};
const tableWindowStyle = {
    position: 'relative',
    width: '100%',
};
exports.RedrawContext = react_1.createContext(undefined);
function useTableRedraw() {
    return react_1.useContext(exports.RedrawContext);
}
exports.useTableRedraw = useTableRedraw;
function useInUnitTest() {
    return process.env.NODE_ENV === 'test';
}
//# sourceMappingURL=DataSourceRendererVirtual.js.map