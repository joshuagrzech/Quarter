"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SandyPluginInstance = void 0;
const PluginBase_1 = require("./PluginBase");
const batch_1 = require("../state/batch");
const atom_1 = require("../state/atom");
class SandyPluginInstance extends PluginBase_1.BasePluginInstance {
    constructor(flipperLib, definition, realClient, pluginKey, initialStates) {
        super(flipperLib, definition, realClient.deviceSync, pluginKey, initialStates);
        this.connected = atom_1.createState(false);
        this.realClient = realClient;
        this.definition = definition;
        const self = this;
        this.client = {
            ...this.createBasePluginClient(),
            get appId() {
                return realClient.id;
            },
            get appName() {
                return realClient.query.app;
            },
            connected: self.connected,
            get isConnected() {
                return self.connected.get();
            },
            onConnect: (cb) => {
                this.events.on('connect', batch_1.batched(cb));
            },
            onDisconnect: (cb) => {
                this.events.on('disconnect', batch_1.batched(cb));
            },
            send: async (method, params) => {
                this.assertConnected();
                return await realClient.call(this.definition.id, method, true, params);
            },
            onMessage: (event, cb) => {
                this.events.on('event-' + event, batch_1.batched(cb));
            },
            onUnhandledMessage: (cb) => {
                this.events.on('unhandled-event', batch_1.batched(cb));
            },
            supportsMethod: async (method) => {
                this.assertConnected();
                return await realClient.supportsMethod(this.definition.id, method);
            },
            isPluginAvailable(pluginId) {
                return flipperLib.isPluginAvailable(realClient.deviceSync, realClient, pluginId);
            },
            selectPlugin(pluginId, deeplink) {
                if (this.isPluginAvailable(pluginId)) {
                    flipperLib.selectPlugin(realClient.deviceSync, realClient, pluginId, deeplink);
                }
            },
        };
        this.initializePlugin(() => definition.asPluginModule().plugin(this.client));
    }
    static is(thing) {
        return thing instanceof SandyPluginInstance;
    }
    activate() {
        super.activate();
        const pluginId = this.definition.id;
        if (!this.connected.get() &&
            !this.realClient.isBackgroundPlugin(pluginId)) {
            this.realClient.initPlugin(pluginId);
        }
    }
    deactivate() {
        super.deactivate();
        const pluginId = this.definition.id;
        if (this.connected.get() && !this.realClient.isBackgroundPlugin(pluginId)) {
            this.realClient.deinitPlugin(pluginId);
        }
    }
    connect() {
        this.assertNotDestroyed();
        if (!this.connected.get()) {
            this.connected.set(true);
            this.events.emit('connect');
        }
    }
    disconnect() {
        this.assertNotDestroyed();
        if (this.connected.get()) {
            this.connected.set(false);
            this.events.emit('disconnect');
        }
    }
    destroy() {
        if (this.connected.get()) {
            this.realClient.deinitPlugin(this.definition.id);
        }
        super.destroy();
    }
    receiveMessages(messages) {
        messages.forEach((message) => {
            if (this.events.listenerCount('event-' + message.method) > 0) {
                this.events.emit('event-' + message.method, message.params);
            }
            else {
                this.events.emit('unhandled-event', message.method, message.params);
            }
        });
    }
    toJSON() {
        return '[SandyPluginInstance]';
    }
    assertConnected() {
        this.assertNotDestroyed();
        if (!this.connected.get() ||
            !this.realClient.connected.get() ||
            !this.device.isConnected ||
            this.device.isArchived) {
            throw new Error('Plugin is not connected');
        }
    }
}
exports.SandyPluginInstance = SandyPluginInstance;
//# sourceMappingURL=Plugin.js.map