"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BasePluginInstance = exports.registerStorageAtom = exports.getCurrentPluginInstance = exports.setCurrentPluginInstance = void 0;
const antd_1 = require("antd");
const events_1 = require("events");
const MenuEntry_1 = require("./MenuEntry");
const batch_1 = require("../state/batch");
let currentPluginInstance = undefined;
function setCurrentPluginInstance(instance) {
    currentPluginInstance = instance;
}
exports.setCurrentPluginInstance = setCurrentPluginInstance;
function getCurrentPluginInstance() {
    return currentPluginInstance;
}
exports.getCurrentPluginInstance = getCurrentPluginInstance;
function registerStorageAtom(key, persistable) {
    if (key && getCurrentPluginInstance()) {
        const { rootStates } = getCurrentPluginInstance();
        if (rootStates[key]) {
            throw new Error(`Some other state is already persisting with key "${key}"`);
        }
        rootStates[key] = persistable;
    }
}
exports.registerStorageAtom = registerStorageAtom;
class BasePluginInstance {
    constructor(flipperLib, definition, realDevice, pluginKey, initialStates) {
        this.activated = false;
        this.destroyed = false;
        this.events = new events_1.EventEmitter();
        this.rootStates = {};
        this.menuEntries = [];
        this.logListeners = [];
        this.flipperLib = flipperLib;
        this.definition = definition;
        this.initialStates = initialStates;
        this.pluginKey = pluginKey;
        if (!realDevice) {
            throw new Error('Illegal State: Device has not yet been loaded');
        }
        this.device = {
            realDevice,
            os: realDevice.os,
            serial: realDevice.serial,
            get isArchived() {
                return realDevice.isArchived;
            },
            get isConnected() {
                return realDevice.connected.get();
            },
            deviceType: realDevice.deviceType,
            onLogEntry: (cb) => {
                const handle = realDevice.addLogListener(cb);
                this.logListeners.push(handle);
                return () => {
                    realDevice.removeLogListener(handle);
                };
            },
        };
    }
    initializePlugin(factory) {
        setCurrentPluginInstance(this);
        try {
            this.instanceApi = batch_1.batched(factory)();
        }
        finally {
            if (this.importHandler && Object.keys(this.rootStates).length > 0) {
                throw new Error(`A custom onImport handler was defined for plugin '${this.definition.id}', the 'persist' option of states ${Object.keys(this.rootStates).join(', ')} should not be set.`);
            }
            if (this.initialStates) {
                try {
                    if (this.importHandler) {
                        batch_1.batched(this.importHandler)(this.initialStates);
                    }
                    else {
                        for (const key in this.rootStates) {
                            if (key in this.initialStates) {
                                this.rootStates[key].deserialize(this.initialStates[key]);
                            }
                            else {
                                console.warn(`Tried to initialize plugin with existing data, however data for "${key}" is missing. Was the export created with a different Flipper version?`);
                            }
                        }
                    }
                }
                catch (e) {
                    const msg = `An error occurred when importing data for plugin '${this.definition.id}': '${e}`;
                    console.error(msg, e);
                    antd_1.message.error(msg);
                }
            }
            this.initialStates = undefined;
            setCurrentPluginInstance(undefined);
        }
        try {
            this.events.emit('ready');
        }
        catch (e) {
            const msg = `An error occurred when initializing plugin '${this.definition.id}': '${e}`;
            console.error(msg, e);
            antd_1.message.error(msg);
        }
    }
    createBasePluginClient() {
        return {
            pluginKey: this.pluginKey,
            device: this.device,
            onActivate: (cb) => {
                this.events.on('activate', batch_1.batched(cb));
            },
            onDeactivate: (cb) => {
                this.events.on('deactivate', batch_1.batched(cb));
            },
            onDeepLink: (cb) => {
                this.events.on('deeplink', batch_1.batched(cb));
            },
            onDestroy: (cb) => {
                this.events.on('destroy', batch_1.batched(cb));
            },
            onExport: (cb) => {
                if (this.exportHandler) {
                    throw new Error('onExport handler already set');
                }
                this.exportHandler = cb;
            },
            onImport: (cb) => {
                if (this.importHandler) {
                    throw new Error('onImport handler already set');
                }
                this.importHandler = cb;
            },
            onReady: (cb) => {
                this.events.on('ready', batch_1.batched(cb));
            },
            addMenuEntry: (...entries) => {
                for (const entry of entries) {
                    const normalized = MenuEntry_1.normalizeMenuEntry(entry);
                    const idx = this.menuEntries.findIndex((existing) => existing.label === normalized.label ||
                        existing.action === normalized.action);
                    if (idx !== -1) {
                        this.menuEntries[idx] = MenuEntry_1.normalizeMenuEntry(entry);
                    }
                    else {
                        this.menuEntries.push(MenuEntry_1.normalizeMenuEntry(entry));
                    }
                    if (this.activated) {
                        this.flipperLib.enableMenuEntries(this.menuEntries);
                    }
                }
            },
            writeTextToClipboard: this.flipperLib.writeTextToClipboard,
            createPaste: this.flipperLib.createPaste,
            isFB: this.flipperLib.isFB,
            GK: this.flipperLib.GK,
            showNotification: (notification) => {
                this.flipperLib.showNotification(this.pluginKey, notification);
            },
            logger: this.flipperLib.logger,
        };
    }
    activate() {
        this.assertNotDestroyed();
        if (!this.activated) {
            this.flipperLib.enableMenuEntries(this.menuEntries);
            this.activated = true;
            this.events.emit('activate');
            this.flipperLib.logger.trackTimeSince(`activePlugin-${this.definition.id}`);
        }
    }
    deactivate() {
        if (this.destroyed) {
            return;
        }
        if (this.activated) {
            this.activated = false;
            this.lastDeeplink = undefined;
            this.events.emit('deactivate');
        }
    }
    destroy() {
        this.assertNotDestroyed();
        this.deactivate();
        this.logListeners.splice(0).forEach((handle) => {
            this.device.realDevice.removeLogListener(handle);
        });
        this.events.emit('destroy');
        this.destroyed = true;
    }
    triggerDeepLink(deepLink) {
        this.assertNotDestroyed();
        if (deepLink !== this.lastDeeplink) {
            this.lastDeeplink = deepLink;
            if (typeof setImmediate !== 'undefined') {
                setImmediate(() => {
                    this.events.emit('deeplink', deepLink);
                });
            }
            else {
                this.events.emit('deeplink', deepLink);
            }
        }
    }
    exportStateSync() {
        if (this.exportHandler) {
            throw new Error('Cannot export sync a plugin that does have an export handler');
        }
        return this.serializeRootStates();
    }
    serializeRootStates() {
        return Object.fromEntries(Object.entries(this.rootStates).map(([key, atom]) => [
            key,
            atom.serialize(),
        ]));
    }
    async exportState(idler, onStatusMessage) {
        if (this.exportHandler) {
            const result = await this.exportHandler(idler, onStatusMessage);
            if (result !== undefined) {
                return result;
            }
        }
        return this.serializeRootStates();
    }
    isPersistable() {
        return !!this.exportHandler || Object.keys(this.rootStates).length > 0;
    }
    assertNotDestroyed() {
        if (this.destroyed) {
            throw new Error('Plugin has been destroyed already');
        }
    }
}
exports.BasePluginInstance = BasePluginInstance;
//# sourceMappingURL=PluginBase.js.map