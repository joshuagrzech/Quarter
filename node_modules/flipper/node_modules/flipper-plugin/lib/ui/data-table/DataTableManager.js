"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeAddRangeToSelection = exports.computeSetSelection = exports.safeCreateRegExp = exports.computeDataTableFilter = exports.savePreferences = exports.getSelectedItems = exports.getSelectedItem = exports.createInitialState = exports.createDataTableManager = exports.dataTableManagerReducer = void 0;
const immer_1 = __importStar(require("immer"));
const emptySelection = {
    items: new Set(),
    current: -1,
};
exports.dataTableManagerReducer = immer_1.default(function (draft, action) {
    var _a;
    const config = immer_1.original(draft.config);
    switch (action.type) {
        case 'reset': {
            draft.columns = computeInitialColumns(config.defaultColumns);
            draft.sorting = undefined;
            draft.searchValue = '';
            draft.selection = immer_1.castDraft(emptySelection);
            break;
        }
        case 'resizeColumn': {
            const { column, width } = action;
            const col = draft.columns.find((c) => c.key === column);
            col.width = width;
            break;
        }
        case 'sortColumn': {
            const { column, direction } = action;
            if (direction === undefined) {
                draft.sorting = undefined;
            }
            else {
                draft.sorting = { key: column, direction };
            }
            break;
        }
        case 'toggleColumnVisibility': {
            const { column } = action;
            const col = draft.columns.find((c) => c.key === column);
            col.visible = !col.visible;
            break;
        }
        case 'setSearchValue': {
            draft.searchValue = action.value;
            break;
        }
        case 'toggleUseRegex': {
            draft.useRegex = !draft.useRegex;
            break;
        }
        case 'selectItem': {
            const { nextIndex, addToSelection, allowUnselect } = action;
            draft.selection = immer_1.castDraft(computeSetSelection(draft.selection, nextIndex, addToSelection, allowUnselect));
            break;
        }
        case 'selectItemById': {
            const { id, addToSelection } = action;
            const idx = config.dataSource.getIndexOfKey(id);
            if (idx !== -1) {
                draft.selection = immer_1.castDraft(computeSetSelection(draft.selection, idx, addToSelection));
            }
            break;
        }
        case 'addRangeToSelection': {
            const { start, end, allowUnselect } = action;
            draft.selection = immer_1.castDraft(computeAddRangeToSelection(draft.selection, start, end, allowUnselect));
            break;
        }
        case 'clearSelection': {
            draft.selection = immer_1.castDraft(emptySelection);
            break;
        }
        case 'addColumnFilter': {
            addColumnFilter(draft.columns, action.column, action.value, action.disableOthers);
            break;
        }
        case 'removeColumnFilter': {
            (_a = draft.columns
                .find((c) => c.key === action.column)
                .filters) === null || _a === void 0 ? void 0 : _a.splice(action.index, 1);
            break;
        }
        case 'toggleColumnFilter': {
            const f = draft.columns.find((c) => c.key === action.column).filters[action.index];
            f.enabled = !f.enabled;
            break;
        }
        case 'setColumnFilterFromSelection': {
            const items = getSelectedItems(config.dataSource, draft.selection);
            items.forEach((item, index) => {
                addColumnFilter(draft.columns, action.column, item[action.column], index === 0);
            });
            break;
        }
        case 'appliedInitialScroll': {
            draft.initialOffset = 0;
            break;
        }
        case 'toggleAutoScroll': {
            draft.autoScroll = !draft.autoScroll;
            break;
        }
        case 'setAutoScroll': {
            draft.autoScroll = action.autoScroll;
            break;
        }
        default: {
            throw new Error('Unknown action ' + action.type);
        }
    }
});
function createDataTableManager(dataSource, dispatch, stateRef) {
    return {
        reset() {
            dispatch({ type: 'reset' });
        },
        selectItem(index, addToSelection = false, allowUnselect = false) {
            dispatch({
                type: 'selectItem',
                nextIndex: index,
                addToSelection,
                allowUnselect,
            });
        },
        selectItemById(id, addToSelection = false) {
            dispatch({ type: 'selectItemById', id, addToSelection });
        },
        addRangeToSelection(start, end, allowUnselect = false) {
            dispatch({ type: 'addRangeToSelection', start, end, allowUnselect });
        },
        clearSelection() {
            dispatch({ type: 'clearSelection' });
        },
        getSelectedItem() {
            return getSelectedItem(dataSource, stateRef.current.selection);
        },
        getSelectedItems() {
            return getSelectedItems(dataSource, stateRef.current.selection);
        },
        toggleColumnVisibility(column) {
            dispatch({ type: 'toggleColumnVisibility', column });
        },
        sortColumn(column, direction) {
            dispatch({ type: 'sortColumn', column, direction });
        },
        setSearchValue(value) {
            dispatch({ type: 'setSearchValue', value });
        },
        dataSource,
    };
}
exports.createDataTableManager = createDataTableManager;
function createInitialState(config) {
    var _a, _b, _c, _d, _f;
    const storageKey = `${config.scope}:DataTable:${config.defaultColumns
        .map((c) => c.key)
        .join(',')}`;
    const prefs = config.enablePersistSettings
        ? loadStateFromStorage(storageKey)
        : undefined;
    let initialColumns = computeInitialColumns(config.defaultColumns);
    if (prefs) {
        initialColumns = immer_1.default(initialColumns, (draft) => {
            prefs.columns.forEach((pref) => {
                const existing = draft.find((c) => c.key === pref.key);
                if (existing) {
                    Object.assign(existing, pref);
                }
            });
        });
    }
    const res = {
        config,
        storageKey,
        initialOffset: (_a = prefs === null || prefs === void 0 ? void 0 : prefs.scrollOffset) !== null && _a !== void 0 ? _a : 0,
        usesWrapping: config.defaultColumns.some((col) => col.wrap),
        columns: initialColumns,
        sorting: prefs === null || prefs === void 0 ? void 0 : prefs.sorting,
        selection: (prefs === null || prefs === void 0 ? void 0 : prefs.selection)
            ? {
                current: prefs.selection.current,
                items: new Set(prefs.selection.items),
            }
            : emptySelection,
        searchValue: (_b = prefs === null || prefs === void 0 ? void 0 : prefs.search) !== null && _b !== void 0 ? _b : '',
        useRegex: (_c = prefs === null || prefs === void 0 ? void 0 : prefs.useRegex) !== null && _c !== void 0 ? _c : false,
        autoScroll: (_f = (_d = prefs === null || prefs === void 0 ? void 0 : prefs.autoScroll) !== null && _d !== void 0 ? _d : config.autoScroll) !== null && _f !== void 0 ? _f : false,
    };
    res.config[immer_1.immerable] = false;
    Object.freeze(res.config);
    return res;
}
exports.createInitialState = createInitialState;
function addColumnFilter(columns, columnId, value, disableOthers = false) {
    const column = columns.find((c) => c.key === columnId);
    const filterValue = String(value).toLowerCase();
    const existing = column.filters.find((c) => c.value === filterValue);
    if (existing) {
        existing.enabled = true;
    }
    else {
        column.filters.push({
            label: String(value),
            value: filterValue,
            enabled: true,
        });
    }
    if (disableOthers) {
        column.filters.forEach((c) => {
            if (c.value !== filterValue) {
                c.enabled = false;
            }
        });
    }
}
function getSelectedItem(dataSource, selection) {
    return selection.current < 0
        ? undefined
        : dataSource.view.get(selection.current);
}
exports.getSelectedItem = getSelectedItem;
function getSelectedItems(dataSource, selection) {
    return [...selection.items]
        .sort()
        .map((i) => dataSource.view.get(i))
        .filter(Boolean);
}
exports.getSelectedItems = getSelectedItems;
function savePreferences(state, scrollOffset) {
    if (!state.config.scope || !state.config.enablePersistSettings) {
        return;
    }
    const prefs = {
        search: state.searchValue,
        useRegex: state.useRegex,
        selection: {
            current: state.selection.current,
            items: Array.from(state.selection.items),
        },
        sorting: state.sorting,
        columns: state.columns.map((c) => ({
            key: c.key,
            width: c.width,
            filters: c.filters,
            visible: c.visible,
        })),
        scrollOffset,
        autoScroll: state.autoScroll,
    };
    localStorage.setItem(state.storageKey, JSON.stringify(prefs));
}
exports.savePreferences = savePreferences;
function loadStateFromStorage(storageKey) {
    if (!storageKey) {
        return undefined;
    }
    const state = localStorage.getItem(storageKey);
    if (!state) {
        return undefined;
    }
    try {
        return JSON.parse(state);
    }
    catch (e) {
        return undefined;
    }
}
function computeInitialColumns(columns) {
    const visibleColumnCount = columns.filter((c) => c.visible !== false).length;
    const columnsWithoutWidth = columns.filter((c) => c.visible !== false && c.width === undefined).length;
    return columns.map((c) => {
        var _a, _b, _c;
        return ({
            ...c,
            width: (_a = c.width) !== null && _a !== void 0 ? _a : (columnsWithoutWidth > 1
                ? `${Math.floor(100 / visibleColumnCount)}%`
                : undefined),
            filters: (_c = (_b = c.filters) === null || _b === void 0 ? void 0 : _b.map((f) => ({
                ...f,
                predefined: true,
            }))) !== null && _c !== void 0 ? _c : [],
            visible: c.visible !== false,
        });
    });
}
function computeDataTableFilter(searchValue, useRegex, columns) {
    const searchString = searchValue.toLowerCase();
    const searchRegex = useRegex ? safeCreateRegExp(searchValue) : undefined;
    const filteringColumns = columns.filter((c) => { var _a; return (_a = c.filters) === null || _a === void 0 ? void 0 : _a.some((f) => f.enabled); });
    if (searchValue === '' && !filteringColumns.length) {
        return undefined;
    }
    return function dataTableFilter(item) {
        for (const column of filteringColumns) {
            if (!column.filters.some((f) => f.enabled &&
                String(item[column.key]).toLowerCase().includes(f.value))) {
                return false;
            }
        }
        return Object.values(item).some((v) => searchRegex
            ? searchRegex.test(String(v))
            : String(v).toLowerCase().includes(searchString));
    };
}
exports.computeDataTableFilter = computeDataTableFilter;
function safeCreateRegExp(source) {
    try {
        return new RegExp(source);
    }
    catch (_e) {
        return undefined;
    }
}
exports.safeCreateRegExp = safeCreateRegExp;
function computeSetSelection(base, nextIndex, addToSelection, allowUnselect) {
    const newIndex = typeof nextIndex === 'number' ? nextIndex : nextIndex(base.current);
    if (!addToSelection &&
        allowUnselect &&
        base.items.size === 1 &&
        base.current === newIndex) {
        return emptySelection;
    }
    if (newIndex < 0) {
        return emptySelection;
    }
    if (base.current < 0 || !addToSelection) {
        return {
            current: newIndex,
            items: new Set([newIndex]),
        };
    }
    else {
        const lowest = Math.min(base.current, newIndex);
        const highest = Math.max(base.current, newIndex);
        return {
            current: newIndex,
            items: addIndicesToMultiSelection(base.items, lowest, highest),
        };
    }
}
exports.computeSetSelection = computeSetSelection;
function computeAddRangeToSelection(base, start, end, allowUnselect) {
    if (start === end && allowUnselect) {
        if (base === null || base === void 0 ? void 0 : base.items.has(start)) {
            const copy = new Set(base.items);
            copy.delete(start);
            const current = [...copy];
            if (current.length === 0) {
                return emptySelection;
            }
            return {
                items: copy,
                current: current[current.length - 1],
            };
        }
    }
    const lowest = Math.min(start, end);
    const highest = Math.max(start, end);
    const current = end;
    return {
        items: addIndicesToMultiSelection(base.items, lowest, highest),
        current,
    };
}
exports.computeAddRangeToSelection = computeAddRangeToSelection;
function addIndicesToMultiSelection(base, lowest, highest) {
    const copy = new Set(base);
    for (let i = lowest; i <= highest; i++) {
        copy.add(i);
    }
    return copy;
}
//# sourceMappingURL=DataTableManager.js.map