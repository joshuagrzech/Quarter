"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataTable = void 0;
const react_1 = __importStar(require("react"));
const TableRow_1 = require("./TableRow");
const Layout_1 = require("../Layout");
const TableHead_1 = require("./TableHead");
const index_1 = require("../../data-source/index");
const DataTableManager_1 = require("./DataTableManager");
const TableSearch_1 = require("./TableSearch");
const styled_1 = __importDefault(require("@emotion/styled"));
const theme_1 = require("../theme");
const TableContextMenu_1 = require("./TableContextMenu");
const antd_1 = require("antd");
const icons_1 = require("@ant-design/icons");
const useAssertStableRef_1 = require("../../utils/useAssertStableRef");
const PluginContext_1 = require("../../plugin/PluginContext");
const lodash_1 = require("lodash");
const useInUnitTest_1 = require("../../utils/useInUnitTest");
const createDataSource_1 = require("flipper-plugin/src/state/createDataSource");
function DataTable(props) {
    const { onRowStyle, onSelect, onCopyRows, onContextMenu } = props;
    const dataSource = normalizeDataSourceInput(props);
    useAssertStableRef_1.useAssertStableRef(dataSource, 'dataSource');
    useAssertStableRef_1.useAssertStableRef(onRowStyle, 'onRowStyle');
    useAssertStableRef_1.useAssertStableRef(props.onSelect, 'onRowSelect');
    useAssertStableRef_1.useAssertStableRef(props.columns, 'columns');
    useAssertStableRef_1.useAssertStableRef(onCopyRows, 'onCopyRows');
    useAssertStableRef_1.useAssertStableRef(onContextMenu, 'onContextMenu');
    const isUnitTest = useInUnitTest_1.useInUnitTest();
    const scope = isUnitTest ? "" : PluginContext_1.usePluginInstance().pluginKey;
    const virtualizerRef = react_1.useRef();
    const [tableState, dispatch] = react_1.useReducer(DataTableManager_1.dataTableManagerReducer, undefined, () => DataTableManager_1.createInitialState({
        dataSource,
        defaultColumns: props.columns,
        onSelect,
        scope,
        virtualizerRef,
        autoScroll: props.enableAutoScroll,
        enablePersistSettings: props.enablePersistSettings,
    }));
    const stateRef = react_1.useRef(tableState);
    stateRef.current = tableState;
    const lastOffset = react_1.useRef(0);
    const dragging = react_1.useRef(false);
    const [tableManager] = react_1.useState(() => DataTableManager_1.createDataTableManager(dataSource, dispatch, stateRef));
    if (props.tableManagerRef) {
        props.tableManagerRef.current = tableManager;
    }
    const { columns, selection, searchValue, sorting } = tableState;
    const visibleColumns = react_1.useMemo(() => columns.filter((column) => column.visible), [columns]);
    const renderingConfig = react_1.useMemo(() => {
        let startIndex = 0;
        return {
            columns: visibleColumns,
            onMouseEnter(e, _item, index) {
                if (dragging.current && e.buttons === 1 && props.enableMultiSelect) {
                    tableManager.addRangeToSelection(startIndex, index);
                }
            },
            onMouseDown(e, _item, index) {
                if (!props.enableMultiSelect && e.buttons > 1) {
                    tableManager.selectItem(index, false, true);
                    return;
                }
                if (!dragging.current) {
                    if (e.buttons > 1) {
                        tableManager.addRangeToSelection(index, index, false);
                    }
                    else if (e.ctrlKey || e.metaKey) {
                        tableManager.addRangeToSelection(index, index, true);
                    }
                    else if (e.shiftKey) {
                        tableManager.selectItem(index, true, true);
                    }
                    else {
                        tableManager.selectItem(index, false, true);
                    }
                    dragging.current = true;
                    startIndex = index;
                    function onStopDragSelecting() {
                        dragging.current = false;
                        document.removeEventListener('mouseup', onStopDragSelecting);
                    }
                    document.addEventListener('mouseup', onStopDragSelecting);
                }
            },
            onRowStyle,
            onContextMenu: props.enableContextMenu
                ? () => {
                    var _a;
                    return (_a = contextMenuRef.current) === null || _a === void 0 ? void 0 : _a.call(contextMenuRef);
                }
                : undefined,
        };
    }, [
        visibleColumns,
        tableManager,
        onRowStyle,
        props.enableContextMenu,
        props.enableMultiSelect,
    ]);
    const itemRenderer = react_1.useCallback(function itemRenderer(record, index, renderContext) {
        return (react_1.default.createElement(TableRow_1.TableRow, { key: index, config: renderContext, record: record, itemIndex: index, highlighted: index === selection.current || selection.items.has(index), style: onRowStyle === null || onRowStyle === void 0 ? void 0 : onRowStyle(record) }));
    }, [selection, onRowStyle]);
    const onKeyDown = react_1.useCallback((e) => {
        var _a, _b;
        let handled = true;
        const shiftPressed = e.shiftKey;
        const outputSize = dataSource.view.size;
        const windowSize = props.scrollable
            ? (_b = (_a = virtualizerRef.current) === null || _a === void 0 ? void 0 : _a.virtualItems.length) !== null && _b !== void 0 ? _b : 0
            : dataSource.view.size;
        if (!windowSize) {
            return;
        }
        switch (e.key) {
            case 'ArrowUp':
                tableManager.selectItem((idx) => (idx > 0 ? idx - 1 : 0), shiftPressed);
                break;
            case 'ArrowDown':
                tableManager.selectItem((idx) => (idx < outputSize - 1 ? idx + 1 : idx), shiftPressed);
                break;
            case 'Home':
                tableManager.selectItem(0, shiftPressed);
                break;
            case 'End':
                tableManager.selectItem(outputSize - 1, shiftPressed);
                break;
            case ' ':
            case 'PageDown':
                tableManager.selectItem((idx) => Math.min(outputSize - 1, idx + windowSize - 1), shiftPressed);
                break;
            case 'PageUp':
                tableManager.selectItem((idx) => Math.max(0, idx - windowSize + 1), shiftPressed);
                break;
            case 'Escape':
                tableManager.clearSelection();
                break;
            default:
                handled = false;
        }
        if (handled) {
            e.stopPropagation();
            e.preventDefault();
        }
    }, [dataSource, tableManager, props.scrollable]);
    const [debouncedSetFilter] = react_1.useState(() => {
        const setFilter = (search, useRegex, columns) => {
            dataSource.view.setFilter(DataTableManager_1.computeDataTableFilter(search, useRegex, columns));
        };
        return isUnitTest ? setFilter : lodash_1.debounce(setFilter, 250);
    });
    react_1.useEffect(function updateFilter() {
        debouncedSetFilter(tableState.searchValue, tableState.useRegex, tableState.columns);
    }, [tableState.searchValue, tableState.useRegex, ...tableState.columns.map((c) => c.filters)]);
    react_1.useEffect(function updateSorting() {
        if (tableState.sorting === undefined) {
            dataSource.view.setSortBy(undefined);
            dataSource.view.setReversed(false);
        }
        else {
            dataSource.view.setSortBy(tableState.sorting.key);
            dataSource.view.setReversed(tableState.sorting.direction === 'desc');
        }
    }, [dataSource, tableState.sorting]);
    react_1.useEffect(function triggerSelection() {
        onSelect === null || onSelect === void 0 ? void 0 : onSelect(DataTableManager_1.getSelectedItem(dataSource, tableState.selection), DataTableManager_1.getSelectedItems(dataSource, tableState.selection));
    }, [onSelect, dataSource, tableState.selection]);
    react_1.useLayoutEffect(function scrollSelectionIntoView() {
        var _a, _b;
        if (tableState.initialOffset) {
            (_a = virtualizerRef.current) === null || _a === void 0 ? void 0 : _a.scrollToOffset(tableState.initialOffset);
            dispatch({
                type: 'appliedInitialScroll',
            });
        }
        else if (selection && selection.current >= 0) {
            dispatch({ type: 'setAutoScroll', autoScroll: false });
            (_b = virtualizerRef.current) === null || _b === void 0 ? void 0 : _b.scrollToIndex(selection.current, {
                align: 'auto',
            });
        }
    }, [selection]);
    const [range, setRange] = react_1.useState('');
    const hideRange = react_1.useRef();
    const onRangeChange = react_1.useCallback((start, end, total, offset) => {
        setRange(`${start} - ${end} / ${total}`);
        lastOffset.current = offset;
        clearTimeout(hideRange.current);
        hideRange.current = setTimeout(() => {
            setRange('');
        }, 1000);
    }, []);
    const onUpdateAutoScroll = react_1.useCallback((autoScroll) => {
        if (props.enableAutoScroll) {
            dispatch({ type: 'setAutoScroll', autoScroll });
        }
    }, [props.enableAutoScroll]);
    const contexMenu = isUnitTest
        ? undefined
        :
            react_1.useCallback(() => TableContextMenu_1.tableContextMenuFactory(dataSource, dispatch, selection, tableState.columns, visibleColumns, onCopyRows, onContextMenu), [
                dataSource,
                dispatch,
                selection,
                tableState.columns,
                visibleColumns,
                onCopyRows,
                onContextMenu,
            ]);
    const contextMenuRef = react_1.useRef(contexMenu);
    contextMenuRef.current = contexMenu;
    react_1.useEffect(function initialSetup() {
        return function cleanup() {
            DataTableManager_1.savePreferences(stateRef.current, lastOffset.current);
            dataSource.view.reset();
            if (props.tableManagerRef) {
                props.tableManagerRef.current = undefined;
            }
        };
    }, []);
    const header = (react_1.default.createElement(Layout_1.Layout.Container, null,
        props.enableSearchbar && (react_1.default.createElement(TableSearch_1.TableSearch, { searchValue: searchValue, useRegex: tableState.useRegex, dispatch: dispatch, contextMenu: props.enableContextMenu ? contexMenu : undefined, extraActions: props.extraActions })),
        props.enableColumnHeaders && (react_1.default.createElement(TableHead_1.TableHead, { visibleColumns: visibleColumns, dispatch: dispatch, sorting: sorting, scrollbarSize: props.scrollable
                ? 0
                : 15 }))));
    const emptyRenderer = props.onRenderEmpty === undefined
        ? props.onRenderEmpty
        : props.onRenderEmpty;
    const mainSection = props.scrollable ? (react_1.default.createElement(Layout_1.Layout.Top, null,
        header,
        react_1.default.createElement(index_1.DataSourceRendererVirtual, { dataSource: dataSource, autoScroll: tableState.autoScroll && !dragging.current, useFixedRowHeight: !tableState.usesWrapping, defaultRowHeight: TableRow_1.DEFAULT_ROW_HEIGHT, context: renderingConfig, itemRenderer: itemRenderer, onKeyDown: onKeyDown, virtualizerRef: virtualizerRef, onRangeChange: onRangeChange, onUpdateAutoScroll: onUpdateAutoScroll, emptyRenderer: emptyRenderer }))) : (react_1.default.createElement(Layout_1.Layout.Container, null,
        header,
        react_1.default.createElement(index_1.DataSourceRendererStatic, { dataSource: dataSource, useFixedRowHeight: !tableState.usesWrapping, defaultRowHeight: TableRow_1.DEFAULT_ROW_HEIGHT, context: renderingConfig, itemRenderer: itemRenderer, onKeyDown: onKeyDown, emptyRenderer: emptyRenderer })));
    return (react_1.default.createElement(Layout_1.Layout.Container, { grow: props.scrollable },
        mainSection,
        props.enableAutoScroll && (react_1.default.createElement(AutoScroller, null,
            react_1.default.createElement(icons_1.PushpinFilled, { style: {
                    color: tableState.autoScroll ? theme_1.theme.textColorActive : undefined,
                }, onClick: () => {
                    dispatch({ type: 'toggleAutoScroll' });
                } }))),
        range && !isUnitTest && react_1.default.createElement(RangeFinder, null, range)));
}
exports.DataTable = DataTable;
DataTable.defaultProps = {
    scrollable: true,
    enableSearchbar: true,
    enableAutoScroll: false,
    enableColumnHeaders: true,
    enableMultiSelect: true,
    enableContextMenu: true,
    onRenderEmpty: emptyRenderer,
};
function normalizeDataSourceInput(props) {
    if (props.dataSource) {
        return props.dataSource;
    }
    if (props.records) {
        const [dataSource] = react_1.useState(() => createDataSource_1.createDataSource(props.records, { key: props.recordsKey }));
        react_1.useEffect(() => {
            syncRecordsToDataSource(dataSource, props.records);
        }, [dataSource, props.records]);
        return dataSource;
    }
    throw new Error(`Either the 'dataSource' or 'records' prop should be provided to DataTable`);
}
function syncRecordsToDataSource(ds, records) {
    const startTime = Date.now();
    ds.clear();
    records.forEach((r) => ds.append(r));
    const duration = Math.abs(Date.now() - startTime);
    if (duration > 50 || records.length > 500) {
        console.warn("The 'records' props is only intended to be used on small datasets. Please use a 'dataSource' instead. See createDataSource for details: https://fbflipper.com/docs/extending/flipper-plugin#createdatasource");
    }
}
function emptyRenderer(dataSource) {
    return react_1.default.createElement(EmptyTable, { dataSource: dataSource });
}
function EmptyTable({ dataSource }) {
    return (react_1.default.createElement(Layout_1.Layout.Container, { center: true, style: { width: '100%', padding: 40, color: theme_1.theme.textColorSecondary } }, dataSource.records.length === 0 ? (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(icons_1.CoffeeOutlined, { style: { fontSize: '2em', margin: 8 } }),
        react_1.default.createElement(antd_1.Typography.Text, { type: "secondary" }, "No records yet"))) : (react_1.default.createElement(react_1.default.Fragment, null,
        react_1.default.createElement(icons_1.SearchOutlined, { style: { fontSize: '2em', margin: 8 } }),
        react_1.default.createElement(antd_1.Typography.Text, { type: "secondary" }, "No records match the current search / filter criteria")))));
}
const RangeFinder = styled_1.default.div({
    backgroundColor: theme_1.theme.backgroundWash,
    position: 'absolute',
    right: 64,
    bottom: 20,
    padding: '4px 8px',
    color: theme_1.theme.textColorSecondary,
    fontSize: '0.8em',
});
const AutoScroller = styled_1.default.div({
    backgroundColor: theme_1.theme.backgroundWash,
    position: 'absolute',
    right: 40,
    bottom: 20,
    width: 24,
    padding: '4px 8px',
    color: theme_1.theme.textColorSecondary,
    fontSize: '0.8em',
});
//# sourceMappingURL=DataTable.js.map