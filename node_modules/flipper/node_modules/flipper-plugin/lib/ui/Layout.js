"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Layout = void 0;
const react_1 = __importStar(require("react"));
const styled_1 = __importDefault(require("@emotion/styled"));
const theme_1 = require("./theme");
const Container = styled_1.default.div(({ bordered, borderBottom, borderLeft, borderRight, borderTop, rounded, width, height, grow, shrink, gap, center, ...rest }) => ({
    display: 'flex',
    flexDirection: 'column',
    flex: grow && shrink
        ? `1 1 0`
        : grow
            ? `1 0 auto`
            : shrink
                ? `0 1 0`
                : `0 0 auto`,
    alignItems: center ? 'center' : 'stretch',
    gap: theme_1.normalizeSpace(gap, theme_1.theme.space.small),
    minWidth: shrink ? 0 : undefined,
    maxWidth: shrink ? '100%' : undefined,
    boxSizing: 'border-box',
    width,
    height,
    padding: theme_1.normalizePadding(rest),
    borderRadius: rounded ? theme_1.theme.containerBorderRadius : undefined,
    borderStyle: 'solid',
    borderColor: theme_1.theme.dividerColor,
    borderWidth: bordered
        ? 1
        : `${borderTop ? 1 : 0}px ${borderRight ? 1 : 0}px ${borderBottom ? 1 : 0}px ${borderLeft ? 1 : 0}px`,
}));
const Horizontal = styled_1.default(Container)({
    flexDirection: 'row',
});
const ScrollParent = styled_1.default.div(({ axis }) => ({
    flex: `1 1 0`,
    boxSizing: 'border-box',
    position: 'relative',
    overflowX: axis === 'y' ? 'hidden' : 'auto',
    overflowY: axis === 'x' ? 'hidden' : 'auto',
}));
const ScrollChild = styled_1.default(Container)(({ axis }) => ({
    position: 'absolute',
    minHeight: '100%',
    minWidth: '100%',
    maxWidth: axis === 'y' ? '100%' : undefined,
    maxHeight: axis === 'x' ? '100%' : undefined,
}));
const ScrollContainer = react_1.forwardRef(({ children, horizontal, vertical, padv, padh, pad, ...rest }, ref) => {
    const axis = horizontal && !vertical ? 'x' : !horizontal && vertical ? 'y' : 'both';
    return (react_1.default.createElement(ScrollParent, { axis: axis, ...rest, ref: ref },
        react_1.default.createElement(ScrollChild, { axis: axis, padv: padv, padh: padh, pad: pad }, children)));
});
const Empty = styled_1.default.div({ width: 0, height: 0 });
function renderSplitLayout(props, direction, grow) {
    let [child1, child2] = props.children;
    if (!child1) {
        child1 = react_1.default.createElement(Empty, null);
    }
    if (!child2) {
        child2 = react_1.default.createElement(Empty, null);
    }
    if ('resizable' in props && props.resizable) {
        const { width, height, minHeight, minWidth, maxHeight, maxWidth } = props;
        const sizeProps = direction === 'column'
            ? {
                minHeight,
                height: height !== null && height !== void 0 ? height : 300,
                maxHeight,
            }
            : {
                minWidth,
                width: width !== null && width !== void 0 ? width : 300,
                maxWidth,
            };
        const Sidebar = require('./Sidebar').Sidebar;
        if (grow === 2) {
            child1 = (react_1.default.createElement(Sidebar, { position: direction === 'column' ? 'top' : 'left', ...sizeProps }, child1));
        }
        else {
            child2 = (react_1.default.createElement(Sidebar, { position: direction === 'column' ? 'bottom' : 'right', ...sizeProps }, child2));
        }
    }
    return (react_1.default.createElement(SandySplitContainer, { ...props, flexDirection: direction, grow: grow },
        child1,
        child2));
}
exports.Layout = {
    Top(props) {
        return renderSplitLayout(props, 'column', 2);
    },
    Bottom(props) {
        return renderSplitLayout(props, 'column', 1);
    },
    Left(props) {
        return renderSplitLayout(props, 'row', 2);
    },
    Right(props) {
        return renderSplitLayout(props, 'row', 1);
    },
    Container,
    ScrollContainer,
    Horizontal,
};
Object.keys(exports.Layout).forEach((key) => {
    exports.Layout[key].displayName = `Layout.${key}`;
});
const SandySplitContainer = styled_1.default.div((props) => ({
    boxSizing: 'border-box',
    display: 'flex',
    flex: `1 1 0`,
    flexDirection: props.flexDirection,
    alignItems: props.center ? 'center' : 'stretch',
    gap: theme_1.normalizeSpace(props.gap, theme_1.theme.space.small),
    overflow: props.center ? undefined : 'hidden',
    '>:nth-child(1)': {
        flex: props.grow === 1 ? splitGrowStyle : splitFixedStyle,
        minWidth: props.grow === 1 ? 0 : undefined,
    },
    '>:nth-child(2)': {
        flex: props.grow === 2 ? splitGrowStyle : splitFixedStyle,
        minWidth: props.grow === 2 ? 0 : undefined,
    },
}));
const splitFixedStyle = `0 0 auto`;
const splitGrowStyle = `1 0 0`;
//# sourceMappingURL=Layout.js.map