"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Elements = exports.ElementsConstants = void 0;
const antd_1 = require("antd");
const react_1 = require("react");
const styled_1 = __importDefault(require("@emotion/styled"));
const react_2 = __importDefault(require("react"));
const theme_1 = require("../theme");
const Layout_1 = require("../Layout");
const FlipperLib_1 = require("flipper-plugin/src/plugin/FlipperLib");
const icons_1 = require("@ant-design/icons");
const { Text } = antd_1.Typography;
const contextMenuTrigger = ['contextMenu'];
exports.ElementsConstants = {
    rowHeight: 23,
};
const backgroundColor = (props) => {
    if (props.selected) {
        return '#4d84f5';
    }
    else if (props.isQueryMatch) {
        return '#4d84f5';
    }
    else if (props.focused) {
        return '#00CF52';
    }
    else if (props.even) {
        return '#f6f7f9';
    }
    else {
        return '';
    }
};
const backgroundColorHover = (props) => {
    if (props.selected) {
        return '#4d84f5';
    }
    else if (props.focused) {
        return '#00CF52';
    }
    else {
        return '#EBF1FB';
    }
};
const ElementsRowContainer = styled_1.default(Layout_1.Layout.Horizontal)((props) => ({
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: backgroundColor(props),
    color: props.selected || props.focused ? theme_1.theme.backgroundDefault : '#58409b',
    flexShrink: 0,
    flexWrap: 'nowrap',
    height: exports.ElementsConstants.rowHeight,
    paddingLeft: (props.level - 1) * 12,
    paddingRight: 20,
    position: 'relative',
    '& *': {
        color: props.selected || props.focused
            ? `${theme_1.theme.backgroundDefault} !important`
            : '',
    },
    '&:hover': {
        backgroundColor: backgroundColorHover(props),
    },
}));
ElementsRowContainer.displayName = 'Elements:ElementsRowContainer';
const ElementsRowDecoration = styled_1.default(Layout_1.Layout.Horizontal)({
    flexShrink: 0,
    justifyContent: 'flex-end',
    alignItems: 'center',
    marginRight: 4,
    position: 'relative',
    width: 16,
    top: -1,
});
ElementsRowDecoration.displayName = 'Elements:ElementsRowDecoration';
const ElementsLine = styled_1.default.div((props) => ({
    backgroundColor: '#bec2c9',
    height: props.childrenCount * exports.ElementsConstants.rowHeight - 4,
    position: 'absolute',
    right: 3,
    top: exports.ElementsConstants.rowHeight - 3,
    zIndex: 2,
    width: 2,
    borderRadius: '999em',
}));
ElementsLine.displayName = 'Elements:ElementsLine';
const DecorationImage = styled_1.default.img({
    height: 12,
    marginRight: 5,
    width: 12,
});
DecorationImage.displayName = 'Elements:DecorationImage';
const NoShrinkText = styled_1.default(Text)({
    flexShrink: 0,
    flexWrap: 'nowrap',
    overflow: 'hidden',
    fontWeight: 400,
    font: theme_1.theme.monospace.fontFamily,
    fontSize: theme_1.theme.monospace.fontSize,
});
NoShrinkText.displayName = 'Elements:NoShrinkText';
const ElementsRowAttributeContainer = styled_1.default(NoShrinkText)({
    color: '#333333',
    fontWeight: 300,
    marginLeft: 5,
});
ElementsRowAttributeContainer.displayName =
    'Elements:ElementsRowAttributeContainer';
const ElementsRowAttributeKey = styled_1.default.span({
    color: '#fb724b',
});
ElementsRowAttributeKey.displayName = 'Elements:ElementsRowAttributeKey';
const ElementsRowAttributeValue = styled_1.default.span({
    color: '#688694',
});
ElementsRowAttributeValue.displayName = 'Elements:ElementsRowAttributeValue';
class PartialHighlight extends react_1.PureComponent {
    render() {
        const { highlighted, content, selected } = this.props;
        if (content &&
            highlighted != null &&
            highlighted != '' &&
            content.toLowerCase().includes(highlighted.toLowerCase())) {
            const highlightStart = content
                .toLowerCase()
                .indexOf(highlighted.toLowerCase());
            const highlightEnd = highlightStart + highlighted.length;
            const before = content.substring(0, highlightStart);
            const match = content.substring(highlightStart, highlightEnd);
            const after = content.substring(highlightEnd);
            return (react_2.default.createElement("span", null,
                before,
                react_2.default.createElement(PartialHighlight.HighlightedText, { selected: selected }, match),
                after));
        }
        else {
            return react_2.default.createElement("span", null, content);
        }
    }
}
PartialHighlight.HighlightedText = styled_1.default.span((props) => ({
    backgroundColor: '#fcd872',
    color: props.selected ? `${'#58409b'} !important` : 'auto',
}));
class ElementsRowAttribute extends react_1.PureComponent {
    render() {
        const { name, value, matchingSearchQuery, selected } = this.props;
        return (react_2.default.createElement(ElementsRowAttributeContainer, null,
            react_2.default.createElement(ElementsRowAttributeKey, null, name),
            "=",
            react_2.default.createElement(ElementsRowAttributeValue, null,
                react_2.default.createElement(PartialHighlight, { content: value, highlighted: name === 'id' || name === 'addr' ? matchingSearchQuery : '', selected: selected }))));
    }
}
class ElementsRow extends react_1.PureComponent {
    constructor(props, context) {
        super(props, context);
        this.getContextMenu = () => {
            var _a;
            const { props } = this;
            let items = [
                {
                    label: 'Copy',
                    click: () => {
                        var _a;
                        (_a = FlipperLib_1.tryGetFlipperLibImplementation()) === null || _a === void 0 ? void 0 : _a.writeTextToClipboard(props.onCopyExpandedTree(props.element, 0));
                    },
                },
                {
                    label: 'Copy expanded child elements',
                    click: () => {
                        var _a;
                        return (_a = FlipperLib_1.tryGetFlipperLibImplementation()) === null || _a === void 0 ? void 0 : _a.writeTextToClipboard(props.onCopyExpandedTree(props.element, 255));
                    },
                },
                {
                    label: props.element.expanded ? 'Collapse' : 'Expand',
                    click: () => {
                        this.props.onElementExpanded(this.props.id, false);
                    },
                },
                {
                    label: props.element.expanded
                        ? 'Collapse all child elements'
                        : 'Expand all child elements',
                    click: () => {
                        this.props.onElementExpanded(this.props.id, true);
                    },
                },
            ];
            items = items.concat(props.element.attributes.map((o) => {
                return {
                    label: `Copy ${o.name}`,
                    click: () => {
                        var _a;
                        (_a = FlipperLib_1.tryGetFlipperLibImplementation()) === null || _a === void 0 ? void 0 : _a.writeTextToClipboard(o.value);
                    },
                };
            }));
            const extensions = Array.isArray(props.contextMenuExtensions)
                ? props.contextMenuExtensions
                : (_a = props.contextMenuExtensions) === null || _a === void 0 ? void 0 : _a.call(props);
            extensions === null || extensions === void 0 ? void 0 : extensions.forEach((extension) => {
                items.push({
                    label: extension.label,
                    click: () => extension.click(this.props.id),
                });
            });
            return (react_2.default.createElement(antd_1.Menu, null, items.map(({ label, click }) => (react_2.default.createElement(antd_1.Menu.Item, { key: label, onClick: click }, label)))));
        };
        this.onClick = () => {
            this.props.onElementSelected(this.props.id);
        };
        this.onDoubleClick = (event) => {
            this.props.onElementSelected(this.props.id);
            this.props.onElementExpanded(this.props.id, event.altKey);
        };
        this.onMouseEnter = () => {
            this.setState({ hovered: true });
            if (this.props.onElementHovered) {
                this.props.onElementHovered(this.props.id);
            }
        };
        this.onMouseLeave = () => {
            this.setState({ hovered: false });
            if (this.props.onElementHovered) {
                this.props.onElementHovered(null);
            }
        };
        this.state = { hovered: false };
    }
    render() {
        const { element, id, level, selected, focused, style, even, matchingSearchQuery, decorateRow, forwardedRef, } = this.props;
        const hasChildren = element.children && element.children.length > 0;
        let arrow;
        if (hasChildren) {
            arrow = (react_2.default.createElement("span", { onClick: this.onDoubleClick, role: "button", tabIndex: -1, style: {
                    color: selected || focused ? 'white' : '#1d2129',
                    fontSize: '8px',
                } }, element.expanded ? react_2.default.createElement(icons_1.DownOutlined, null) : react_2.default.createElement(icons_1.RightOutlined, null)));
        }
        const attributes = element.attributes
            ? element.attributes.map((attr) => (react_2.default.createElement(ElementsRowAttribute, { key: attr.name, name: attr.name, value: attr.value, matchingSearchQuery: matchingSearchQuery, selected: selected })))
            : [];
        const decoration = decorateRow
            ? decorateRow(element)
            : defaultDecorateRow(element);
        let line;
        const shouldShowLine = (selected || this.state.hovered) && hasChildren && element.expanded;
        if (shouldShowLine) {
            line = react_2.default.createElement(ElementsLine, { childrenCount: this.props.childrenCount });
        }
        return (react_2.default.createElement(antd_1.Dropdown, { key: id, overlay: this.getContextMenu, trigger: contextMenuTrigger },
            react_2.default.createElement(ElementsRowContainer, { level: level, ref: forwardedRef, selected: selected, focused: focused, matchingSearchQuery: matchingSearchQuery, even: even, onClick: this.onClick, onDoubleClick: this.onDoubleClick, onMouseEnter: this.onMouseEnter, onMouseLeave: this.onMouseLeave, isQueryMatch: this.props.isQueryMatch, style: style },
                react_2.default.createElement(ElementsRowDecoration, null,
                    line,
                    arrow),
                react_2.default.createElement(NoShrinkText, null,
                    decoration,
                    react_2.default.createElement(PartialHighlight, { content: element.name, highlighted: matchingSearchQuery, selected: selected })),
                attributes)));
    }
}
function defaultDecorateRow(element) {
    switch (element.decoration) {
        case 'litho':
            return react_2.default.createElement(DecorationImage, { src: "icons/litho-logo.png" });
        case 'componentkit':
            return react_2.default.createElement(DecorationImage, { src: "icons/componentkit-logo.png" });
        case 'accessibility':
            return react_2.default.createElement(DecorationImage, { src: "icons/accessibility.png" });
        default:
            return null;
    }
}
function containsKeyInSearchResults(searchResults, key) {
    return searchResults != undefined && searchResults.matches.has(key);
}
const ElementsContainer = styled_1.default('div')({
    display: 'table',
    backgroundColor: theme_1.theme.backgroundDefault,
});
ElementsContainer.displayName = 'Elements:ElementsContainer';
class Elements extends react_1.PureComponent {
    constructor(props, context) {
        super(props, context);
        this.selectElement = (key) => {
            this.props.onElementSelected(key);
        };
        this.onKeyDown = (e) => {
            var _a;
            const { selected } = this.props;
            if (selected == null) {
                return;
            }
            const { props } = this;
            const { flatElements, flatKeys } = this.state;
            const selectedIndex = flatKeys.indexOf(selected);
            if (selectedIndex < 0) {
                return;
            }
            const selectedElement = props.elements[selected];
            if (!selectedElement) {
                return;
            }
            if (e.key === 'c' &&
                ((e.metaKey && process.platform === 'darwin') ||
                    (e.ctrlKey && process.platform !== 'darwin'))) {
                e.stopPropagation();
                e.preventDefault();
                (_a = FlipperLib_1.tryGetFlipperLibImplementation()) === null || _a === void 0 ? void 0 : _a.writeTextToClipboard(selectedElement.name);
                return;
            }
            if (e.key === 'ArrowUp') {
                e.stopPropagation();
                if (selectedIndex === 0 || flatKeys.length === 1) {
                    return;
                }
                e.preventDefault();
                this.selectElement(flatKeys[selectedIndex - 1]);
            }
            if (e.key === 'ArrowDown') {
                e.stopPropagation();
                if (selectedIndex === flatKeys.length - 1) {
                    return;
                }
                e.preventDefault();
                this.selectElement(flatKeys[selectedIndex + 1]);
            }
            if (e.key === 'ArrowLeft') {
                e.stopPropagation();
                e.preventDefault();
                if (selectedElement.expanded) {
                    props.onElementExpanded(selected, false);
                }
                else {
                    let parentKey;
                    const targetLevel = flatElements[selectedIndex].level - 1;
                    for (let i = selectedIndex; i >= 0; i--) {
                        const { level } = flatElements[i];
                        if (level === targetLevel) {
                            parentKey = flatKeys[i];
                            break;
                        }
                    }
                    if (parentKey) {
                        this.selectElement(parentKey);
                    }
                }
            }
            if (e.key === 'ArrowRight' && selectedElement.children.length > 0) {
                e.stopPropagation();
                e.preventDefault();
                if (selectedElement.expanded) {
                    this.selectElement(selectedElement.children[0]);
                }
                else {
                    props.onElementExpanded(selected, false);
                }
            }
        };
        this.onElementHoveredHandler = (key) => {
            var _a, _b;
            (_b = (_a = this.props).onElementHovered) === null || _b === void 0 ? void 0 : _b.call(_a, key);
        };
        this.onCopyExpandedTree = (element, maxDepth, depth = 0) => {
            const shouldIncludeChildren = element.expanded && depth < maxDepth;
            const children = shouldIncludeChildren
                ? element.children.map((childId) => {
                    const childElement = this.props.elements[childId];
                    return childElement == null
                        ? ''
                        : this.onCopyExpandedTree(childElement, maxDepth, depth + 1);
                })
                : [];
            const childrenValue = children.toString().replace(',', '');
            const indentation = depth === 0 ? '' : '\n'.padEnd(depth * 2 + 1, ' ');
            const attrs = element.attributes.reduce((acc, val) => acc + ` ${val.name}=${val.value}`, '');
            return `${indentation}${element.name}${attrs}${childrenValue}`;
        };
        this.parentRef = react_1.createRef();
        this.scrollToSelectionRefHandler = (selectedRow) => {
            var _a, _b;
            if (selectedRow && this.state.scrolledElement !== this.props.selected) {
                if (this.parentRef.current &&
                    !isInView(this.parentRef.current, selectedRow)) {
                    (_b = (_a = selectedRow.children[1]) === null || _a === void 0 ? void 0 : _a.scrollIntoView) === null || _b === void 0 ? void 0 : _b.call(_a, {
                        block: 'center',
                        inline: 'center',
                    });
                }
                this.setState({ scrolledElement: this.props.selected });
            }
        };
        this.buildRow = (row, index) => {
            const { onElementExpanded, onElementSelected, selected, focused, searchResults, contextMenuExtensions, decorateRow, } = this.props;
            const { flatElements } = this.state;
            let childrenCount = 0;
            for (let i = index + 1; i < flatElements.length; i++) {
                const child = flatElements[i];
                if (child.level <= row.level) {
                    break;
                }
                else {
                    childrenCount++;
                }
            }
            let isEven = false;
            if (this.props.alternateRowColor) {
                isEven = index % 2 === 0;
            }
            return (react_2.default.createElement(ElementsRow, { level: row.level, id: row.key, key: row.key, even: isEven, onElementExpanded: onElementExpanded, onElementHovered: this.onElementHoveredHandler, onElementSelected: onElementSelected, onCopyExpandedTree: this.onCopyExpandedTree, selected: selected === row.key, focused: focused === row.key, matchingSearchQuery: searchResults && containsKeyInSearchResults(searchResults, row.key)
                    ? searchResults.query
                    : null, isQueryMatch: containsKeyInSearchResults(searchResults, row.key), element: row.element, childrenCount: childrenCount, contextMenuExtensions: contextMenuExtensions, decorateRow: decorateRow, forwardedRef: selected == row.key
                    ? this.scrollToSelectionRefHandler
                    : null }));
        };
        this.state = {
            flatElements: [],
            flatKeys: [],
            maxDepth: 0,
            scrolledElement: null,
        };
    }
    static getDerivedStateFromProps(props) {
        const flatElements = [];
        const flatKeys = [];
        let maxDepth = 0;
        function seed(key, level) {
            const element = props.elements[key];
            if (!element) {
                return;
            }
            maxDepth = Math.max(maxDepth, level);
            flatElements.push({
                element,
                key,
                level,
            });
            flatKeys.push(key);
            if (element.children != null &&
                element.children.length > 0 &&
                element.expanded) {
                for (const key of element.children) {
                    seed(key, level + 1);
                }
            }
        }
        if (props.root != null) {
            seed(props.root, 1);
        }
        else {
            const virtualRoots = new Set();
            Object.keys(props.elements).forEach((id) => virtualRoots.add(id));
            for (const [currentId, element] of Object.entries(props.elements)) {
                if (!element) {
                    virtualRoots.delete(currentId);
                }
                else {
                    element.children.forEach((id) => virtualRoots.delete(id));
                }
            }
            virtualRoots.forEach((id) => seed(id, 1));
        }
        return { flatElements, flatKeys, maxDepth };
    }
    render() {
        return (react_2.default.createElement(ElementsContainer, { onKeyDown: this.onKeyDown, tabIndex: 0, ref: this.parentRef }, this.state.flatElements.map(this.buildRow)));
    }
}
exports.Elements = Elements;
Elements.defaultProps = {
    alternateRowColor: true,
};
function isInView(parent, el) {
    const scrollContainer = parent.parentElement.parentElement;
    if (el.offsetTop > scrollContainer.scrollTop &&
        el.offsetTop < scrollContainer.scrollTop + scrollContainer.clientHeight) {
        const child = el.childNodes[0];
        if (child.offsetLeft > scrollContainer.scrollLeft &&
            child.offsetLeft <
                scrollContainer.scrollLeft + scrollContainer.clientWidth) {
            return true;
        }
    }
    return false;
}
//# sourceMappingURL=elements.js.map