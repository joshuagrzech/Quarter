"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUpdatablePlugins = void 0;
const pluginInstaller_1 = require("./pluginInstaller");
const semver_1 = __importDefault(require("semver"));
const getNpmHostedPlugins_1 = require("./getNpmHostedPlugins");
const npm_api_1 = __importDefault(require("npm-api"));
const getPluginDetails_1 = require("./getPluginDetails");
const pluginPaths_1 = require("./pluginPaths");
const p_map_1 = __importDefault(require("p-map"));
const typeUtils_1 = require("./typeUtils");
const npmApi = new npm_api_1.default();
async function getUpdatablePlugins(query) {
    const installedPlugins = await pluginInstaller_1.getInstalledPlugins();
    const npmHostedPlugins = new Map((await getNpmHostedPlugins_1.getNpmHostedPlugins({ query })).map((p) => [p.name, p]));
    const annotatedInstalledPlugins = await p_map_1.default(installedPlugins, async (installedPlugin) => {
        try {
            const npmPackageDescriptor = npmHostedPlugins.get(installedPlugin.name);
            if (npmPackageDescriptor) {
                npmHostedPlugins.delete(installedPlugin.name);
                if (semver_1.default.lt(installedPlugin.version, npmPackageDescriptor.version)) {
                    const pkg = await npmApi.repo(npmPackageDescriptor.name).package();
                    const npmPluginDetails = await getPluginDetails_1.getInstalledPluginDetails(pluginPaths_1.getPluginVersionInstallationDir(npmPackageDescriptor.name, npmPackageDescriptor.version), pkg);
                    return {
                        ...npmPluginDetails,
                        updateStatus: {
                            kind: 'update-available',
                            version: npmPluginDetails.version,
                        },
                    };
                }
            }
            const updateStatus = { kind: 'up-to-date' };
            return {
                ...installedPlugin,
                updateStatus,
            };
        }
        catch (error) {
            return {
                ...installedPlugin,
                updateStatus: {
                    kind: 'error',
                    error,
                },
            };
        }
    }, {
        concurrency: 4,
    });
    const annotatedNotInstalledPlugins = await p_map_1.default(npmHostedPlugins.values(), async (notInstalledPlugin) => {
        try {
            const pkg = await npmApi.repo(notInstalledPlugin.name).package();
            const npmPluginDetails = getPluginDetails_1.getPluginDetails(pkg);
            if (npmPluginDetails.specVersion === 1) {
                return null;
            }
            return {
                ...npmPluginDetails,
                updateStatus: {
                    kind: 'not-installed',
                    version: npmPluginDetails.version,
                },
            };
        }
        catch (error) {
            console.log(`Failed to load details from npm for plugin ${notInstalledPlugin.name}`, error);
            return null;
        }
    }, {
        concurrency: 4,
    });
    return [
        ...annotatedInstalledPlugins.sort((p1, p2) => p1.name.localeCompare(p2.name)),
        ...annotatedNotInstalledPlugins
            .filter(typeUtils_1.notNull)
            .sort((p1, p2) => p1.name.localeCompare(p2.name)),
    ].filter((p) => {
        var _a, _b;
        return !query ||
            p.name.includes(query) ||
            p.id.includes(query) ||
            ((_a = p.description) === null || _a === void 0 ? void 0 : _a.includes(query)) ||
            ((_b = p.title) === null || _b === void 0 ? void 0 : _b.includes(query));
    });
}
exports.getUpdatablePlugins = getUpdatablePlugins;
//# sourceMappingURL=getUpdatablePlugins.js.map